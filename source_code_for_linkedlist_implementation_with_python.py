{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "8478ecc3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Bata--->Servis--->Stylo--->Hush Puppies--->Ndure--->\n"
     ]
    }
   ],
   "source": [
    "\"\"\"Node class for creating node objects\"\"\"\n",
    "class Node:\n",
    "    \"\"\"Constructor which takes value for the node and the next value in the linked list\"\"\"\n",
    "    def __init__(self, data = None, next = None):\n",
    "        self.data = data\n",
    "        self.next = next\n",
    "        \n",
    "        \n",
    "\"\"\"Linkiedlist Data Structure implementation\"\"\"\n",
    "\n",
    "class Linked_list:\n",
    "    \"\"\"constrcutor for the linked list which has an attribute head that tells us the first value \n",
    "       in the linked list \"\"\"\n",
    "    def __init__(self):\n",
    "        self.head = None\n",
    "    \n",
    "    \"\"\"Method for printing the linked list\"\"\" \n",
    "    def print(self):\n",
    "        if self.head is None: #checks wether the list is empty\n",
    "            print(\"Linked list is empty\")#if the linked list is empty prints \"linked list is empty\"\n",
    "            return #concludes the method\n",
    "        llstr = \"\" #if the list is not empty an empty string is created\n",
    "        itr = self.head # a variable itr is created and assigned the starting node of the linked lsit\n",
    "        while itr: #loop for iterating through the list \n",
    "            llstr +=  str(itr.data) + \"--->\" #it concatinates the current node data to llstr\n",
    "            itr = itr.next #it reassigns the next node to variable itr.\n",
    "        print(llstr) #prints the contents of the linked list\n",
    "    \n",
    "        \n",
    "    \"\"\"Method for inserting value at the begining\"\"\"    \n",
    "    def insert_at_begining(self, data):\n",
    "        node = Node(data, self.head)#it creates a node at the begining\n",
    "        self.head = node #it assigns the current node as the starting node\n",
    "        \n",
    "   \n",
    "    \"\"\"Method for inserting value at the end\"\"\"\n",
    "    def insert_at_end(self,data):\n",
    "        if self.head is None: #checks whether linked list is empty or not\n",
    "            self.head = Node(data, None) #sets the current node as starting node if the list is empty\n",
    "            return\n",
    "        itr = self.head #creates a variable itr, assigns starting node if the list is not empty \n",
    "        while itr.next: #iterates through the linked list \n",
    "            itr = itr.next #reassigns the next node to itr\n",
    "        itr.next = Node(data, None) #creates a node when reaches at the end\n",
    "    \n",
    "    \"\"\"Method for inserting multiple values in an empty linked list\"\"\"\n",
    "    def insert_values(self, data_list):\n",
    "        self.head = None #sets all the nodes to none\n",
    "        for data in data_list: #loop to iterate through the data_list\n",
    "            self.insert_at_end(data) #inserts each value at the end of the linked list\n",
    "    \n",
    "    \"Method for clearing the list\"\n",
    "    def clear_list(self):\n",
    "        self.head = None #sets all the nodes to none making the list empty\n",
    "        self.print() #calls the print function\n",
    "        \n",
    "    \"Method for getting the number of items in the list\"\n",
    "    def get_lenth(self):\n",
    "        count = 0 #counter variable set to zero initially\n",
    "        itr = self.head \n",
    "        while itr: #loop to iterate through the linked list\n",
    "            count +=1 #increases the count by one for each iteration\n",
    "            itr = itr.next #reassigns the next node\n",
    "        return count #returns the number of items\n",
    "    \n",
    "    \"Mehtod for removing an item at a given index\"\n",
    "    def remove_at(self, index):\n",
    "        if index < 0 or index >= self.get_lenth(): #checks whether the index is valid or not\n",
    "            raise Exception(\"Invalid Index\") #raises exception if the index is invalid\n",
    "            \n",
    "        if index == 0: #checks wether or not we are removing starting item\n",
    "            self.head = self.head.next #removes the first item and sets the second item as the first\n",
    "            return\n",
    "        count = 0 #counter initially set to zero\n",
    "        itr = self.head\n",
    "        while itr: #loops through the linked list\n",
    "            if count == index - 1: #check wether or not we have reached one step before the index \n",
    "                itr.next = itr.next.next #removes the index item \n",
    "                break # breaks out of the loop\n",
    "            itr = itr.next\n",
    "            count +=1 #increase the count by one for each iteration\n",
    "    \n",
    "    \"\"\"Method for inserting new item at a given index\"\"\"\n",
    "    def insert_at(self, index, data):\n",
    "        if index < 0 or index >= self.get_lenth(): #checks for valid index\n",
    "            raise Exception(\"Invalid Index\") #raises an exception if the index is invalid\n",
    "        if index == 0: #checks whether we want to add new item at start\n",
    "            self.insert_at_begining(data) #calls insert_at_begining function to insert the item\n",
    "            return\n",
    "        if index == self.get_lenth() - 1: #checks whether we want to insert the item at the end\n",
    "            self.insert_at_end(data) #calls the insert_at_end function to insert the item \n",
    "            return\n",
    "        count = 0\n",
    "        itr = self.head\n",
    "        while itr: #loops through the linked list\n",
    "            if count == index - 1: #checks whether we have reached one step before the index\n",
    "                itr.next = Node(data, itr.next) #adds the new item at index\n",
    "                break #breaks out of the loop\n",
    "            itr = itr.next\n",
    "            count +=1 #increases the count by 1\n",
    "            \n",
    "    \"\"\"Method for inserting an item after an item by value \"\"\"\n",
    "    def insert_after_value(self, data_after, data):\n",
    "        itr = self.head #creates itr variable and assigns it the staring node\n",
    "        while itr: #iterates through the linked list   \n",
    "            if itr.data == data_after: #hecks whether we have reached at the position we want to add the item\n",
    "                node = Node(data, itr.next) #creates a new node for the item\n",
    "                itr.next = node #sets the position of the node after the current item \n",
    "                return\n",
    "            \n",
    "            itr = itr.next #reassigns the next node to itr\n",
    "        else:\n",
    "             raise Exception(f\"{data_after} is not present in the linked list\") #raises exception if the data_after is not present in the linked list\n",
    "    \"\"\"Method for removing an item by value\"\"\"     \n",
    "    def remove_by_value(self, data_to_remove):\n",
    "        itr = self.head\n",
    "        count = 0\n",
    "        while itr:   \n",
    "            if itr.data == data_to_remove:\n",
    "                self.remove_at(count)\n",
    "                return\n",
    "            \n",
    "            itr = itr.next\n",
    "            count +=1\n",
    "        else:\n",
    "             raise Exception(f\"{data_after} is not present in the linked list\")\n",
    "        \n",
    "if __name__ == '__main__':\n",
    "    ll = Linked_list()\n",
    "#     "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
